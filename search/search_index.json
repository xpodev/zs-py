{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"getting-started/classes/","title":"Classes","text":"<p>When we build our program, we notice that we need to handle data, and many times, very similar data.</p> <p>It would be very nice for us, programmers, if we had some way to easily manage data.</p> <p>Fortunately, the Z# language developer does love helping others, and he came up with a way to do that.</p> <ul> <li>The Z# language developer did not invent classes.</li> </ul> <p>To define a class we use the <code>class</code> keyword. <pre><code>class MyClass {\n}\n</code></pre></p> <p>Well, the class that we just created - <code>MyClass</code> - is not very helpful on its own, as it is empty and it doesn't have any data to manage.</p> <ul> <li>I know that it is actually a data structure, but I'm assuming you know what a class is.</li> </ul> <p>So we can define fields in a class. Defining a field in a class is as easy as defining a variable. <pre><code>class MyClass {\nvar my_field: String;\n}\n</code></pre></p> <p>In order to use our class, we first need to add a constructor. <pre><code>class MyClass {\n    var my_field: String;\n\n    fun MyClass(this, some_value: String) {\n        this.my_field = some_value;\n    }\n}\n</code></pre></p> <p>A few notes here:</p> <ul> <li>The constructor name must be the same as the class name.</li> <li>All instance methods must have a <code>this</code> parameter. You can choose whatever name you want tho.</li> <li>By default, if a parameter type is not specified, it is assumed to be <code>any</code> (will change in the future).</li> <li>By default, if no constructor were to be found, an empty constructor is provided by the compiler.</li> </ul> <p>Now that we have defined our constructor, we can use it to create our first object; <pre><code>var my_class = MyClass(\"I'm an object!\");\n\nprint(my_class.my_field);  // Output: I'm an object!\n</code></pre></p>"},{"location":"getting-started/functions/","title":"Functions","text":"<p>One of the most basic building blocks of any program is a function.</p> <p>In order to define a function in Z#, we use the <code>fun</code> keyword (because functions are fun!).</p> <pre><code>fun my_function() {\n}\n</code></pre> <p>The above function is empty, so it doesn't do much. Let's try and create a function to greet the user.</p> <pre><code>fun greet() {\nprint(\"Hello user!\");\n}\n</code></pre> <p>Running the code now will not do anything, and that's because defining a function is not enough. We also need to call it. Calling a function in Z# is easy enough. Just use the call operator (<code>()</code>). <pre><code>greet();  // Output: Hello user!\n</code></pre></p> <p>If you were paying attention, you'd notice that <code>print</code> is also a function, thus we can use the call  operator on it as well!</p> <p>This function is not so useful tho, we want to be able to use it for different people as well, not just people who's name is <code>user</code>...</p> <p>That's why we need parameters. In Z#, we can define parameters in the parameter list of the function definition. <pre><code>fun greet(user) {\nprint(\"Hello \" + user \"!\");\n}\ngreet(\"Benjo\"); // Output: Hello Benjo!\n</code></pre></p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>To install Z# on your machine, you need to install the source code and run it directly.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or above</li> <li>Git</li> </ul>"},{"location":"getting-started/installation/#steps","title":"Steps","text":"<p>First, clone the github repo: <pre><code>git clone https://github.com/xpodev/zs-py.git -b rewrite-core  # (1)!\n</code></pre></p> <ol> <li>The <code>rewrite-core</code> branch is the latest branch (currently).</li> </ol> <p>Add the cloned repo to your PATH.</p> <p>Then, create your first project: <pre><code>zsc new my_project\n</code></pre></p> <p>This will create a new directory <code>my_project</code> which will contain the generated project.</p> <p>Open the generated directory in your favorite IDE and open the <code>main.zs</code> file located in <code>src/</code>.</p> <p>Write the following lines and save the file: main.zs<pre><code>print(\"Hello, World!\");\n</code></pre></p> <p>Run the file: <pre><code>zsc c my_project.main.zs\n</code></pre></p> <p>Expected output: <pre><code>Hello, World!\n</code></pre></p>"},{"location":"getting-started/typeclasses/","title":"TypeClasses","text":"<p>Type classes are very similar to interfaces in other OOP languages, but they differ in a few things:</p> <ul> <li>You don't need to put the typeclass in your inheritence list when defining a class.</li> <li>You can implement a typeclass for any type you want.</li> <li>It does not necessarily defines an object API, but also the class API.</li> </ul> <p>To define a type class, we use the <code>typeclass</code> keyword. Typeclasses must have a name. <pre><code>typeclass MyTypeclass {\n\n}\n</code></pre></p> <p>Inside the typeclass body, you can define the functions you want to be implemented in implementing types. <pre><code>typeclass MyTypeclass {\n    fun my_api(this, value: string);\n}\n</code></pre></p> <p>In order to implement the <code>MyTypeclass</code> typeclass for a certain type (say, string), we do this: <pre><code>typeclass MyTypeclass(string) {\n    fun my_api(this: string, value: string) {\n        print(\"Typeclass.my_api(string, string) is implemented on string! \" + this + value);\n    }\n}\n</code></pre></p> <p>Implementing a typeclass does not change the type. For example, we will not be able to call <code>my_api</code>  on instances of string, even though it does implement the <code>MyTypeclass</code> typeclass which defined <code>my_api</code>.</p> <p>So how do we use typeclasses then?</p> <p>We have to treat instances of implemented types as if they were the type class itself. <pre><code>var my_typeclass: MyTypeclass = \"Hello\";\nmy_typeclass.my_api(\", Typeclasses!\");  // Output: Typeclass.my_api(string, string) is implemented on string! Hello, Typeclasses!\n</code></pre></p>"},{"location":"getting-started/variables/","title":"Variables","text":"<p>Like many other programming languages, Z# supports the basic idea of a variable.</p> <p>Now, Z# is a strongly-typed language, meaning that a variable must have a type which may not be changed during execution.</p> <p>To create a variable, we use the <code>var</code> statement. <pre><code>var my_variable = \"Hello!\";\n</code></pre></p> <p>In the above example, the variable <code>my_variable</code> has the inferred type <code>String</code>, which is a built-in type.</p> <p>When we want to use the variable we created, we can refer to it by its name.</p> <pre><code>print(my_variable);  // Output: Hello!\n</code></pre> <p>We can also reassign variable values with the assignment operator (<code>=</code>) <pre><code>my_variable = \"Bye!\";\nprint(my_variable); // Output: Bye!\n</code></pre></p> <p>Since <code>my_variable</code> has a type <code>String</code>, trying to assign any other type will result with an error. <pre><code>my_variable = 1;  // Error. Can't assign type `i32` to type `String`.\n</code></pre></p>"},{"location":"reference/","title":"Reference","text":""}]}